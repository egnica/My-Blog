<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=
    , initial-scale=1.0"
    />
    <title>Document</title>
  </head>
  <body>
    I was recently in a situation where I was talking to a senior developer, and he was asking me questions about JavaScript to gauge my knowledge. Before this conversation, I felt confident in my JavaScript knowledge. After that conversation, I felt deflated. I realized I still had a lot of work to do. My goal is to become comfortable with the aspects of JavaScript where I fell short during that conversation. To that end, I want to bring clarity to the JavaScript concept of closures. <br><br><h2>Understanding Closures </h2>Closures can seem tricky at first, but they become easier to understand when broken down. A closure happens when a function can 'remember' and access variables from its outer scope, even after that outer scope has finished executing. This unique behavior allows inner functions to retain access to variables defined in an enclosing function.<br><br><strong>Key takeaway:</strong> Closures enable functions to remember and access variables from their surrounding context, even after that context has finished executing. <br><br><br><h2>Example of a Closure</h2>Here’s a simple example to illustrate how closures work:<br><iframe src='https://www.thiscodeworks.com/embed/677d568d74e4d900142b75ab' style='width: 100%; height: 229px;' frameborder='0'></iframe><br><strong>Explanation:</strong><br><ul><li><code>outerFunction</code> takes a parameter <code>outerVariable</code> and logs it.</li><li>It returns <code>innerFunction</code>, which itself takes a parameter <code>innerVariable</code>.</li><li> <code> innerFunction</code> logs both <code>outerVariable</code> and <code>innerVariable.</code></li><li>Even after <code>outerFunction</code> has finished executing, <code>innerFunction</code> retains access to outerVariable due to the closure.</li></ul>
    
    <h2>Breaking Down the Code</h2><h4>Step 1: Defining the Outer Function</h4><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>function outerFunction(outerVariable) </code></span> <br><code>outerFunction</code> is defined with one parameter, <code>outerVariable.</code><h4>Step 2: Returning the Inner Function</h4><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>return function innerFunction(innerVariable)  </code></span><br>Instead of executing <code>innerFunction</code>, <code>outerFunction</code> returns it.The returned <code>innerFunction</code> retains access to <code>outerVariable</code>.<h4>Step 3: Parameters in Scope</h4><code>outerVariable</code> belongs to <code>outerFunction</code>.<h4>Step 4: Logging Inside the Inner Function</h4><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>console.log(`Outer Variable: ${outerVariable}`);</code></span><br><br><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>console.log(`Inner Variable: ${innerVariable}`);</code></span><br><code>innerFunction</code> logs both <code>outerVariable</code> and <code>innerVariable</code>, demonstrating how closures work.

    <h2>How the Function Calls Work</h2><h4>1. Calling outerFunction</h4><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>const closureFunc = outerFunction("outside");</code></span><br><strong>What happens:</strong><br><ul style='padding-left: 20px;'><li><code>outerFunction</code> is called with the argument "outside".</li><li>It logs "outside".</li><li>It returns <code>innerFunction</code>, which gets stored in <code>closureFunc</code>.</li></ul><h4>2. Calling innerFunction via closureFunc</h4><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>closureFunc("inside");</code></span><br><strong>What happens:</strong><ul style='padding-left: 20px;'><li><code>closureFunc</code> is invoked with the argument "inside".</li><li>innerFunction logs:<br><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>Outer Variable: outside</code></span><br><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>Inner VAriable: inside</code></span></li><li>Even though <code>outerFunction</code> has completed, <code>innerFunction</code> still has access to <code>outerVariable</code> because of the closure.</li></ul>

    <h2>closureFunc is the returned innerFunction(), which remembers the outerFunction argument (in this case the string 'outside') and takes a new argument for itself.. in this case ('inside')</h2><ol><li>closureFunc is the returned innerFunction.</li><li>It "remembers" the outerFunction argument (via the closure).</li><li>It also accepts a new argument specifically for innerFunction.</li></ol>
            
<a href="https://www.w3schools.com/js/js_function_parameters.asp">parameter</a>


<h2>Common Misunderstandings</h2>Why doesn’t closureFunc("inside") invoke outerFunction?<br>It might seem like calling closureFunc should somehow trigger outerFunction, but here’s the key point:<ul style='padding-left: 40px;'><li>closureFunc is just a reference to innerFunction.</li><li>outerFunction is no longer involved after returning innerFunction.</li></ul>Even though outerFunction has finished executing, its variables remain accessible to innerFunction because of the closure.<h2>Why Closures Matter</h2>Closures are powerful because they allow:<br><ul style='padding-left: 40px;'><li>Data encapsulation: Variables can be kept private within a function.</li><li>Function factories: You can create functions with preset configurations.</li><li>Maintaining state: Closures help manage state in asynchronous operations.</li></ul><br><br>

<h2>Final Thoughts</h2>Closures are a fundamental concept in JavaScript. While they may seem confusing initially, understanding how they work will deepen your knowledge of JavaScript functions and scope. Closures are widely used in callbacks, function factories, and state management in asynchronous code.<br><br>With practice, closures will become a natural and powerful tool in your JavaScript toolkit.

<a href="https://developer.mozilla.org/en-US/docs/Glossary/Scope">scope</a>
</html>


<pre class='language-js'><code class='language-js'>function outerFunction(outerVariable) {\n return function innerFunction(innerVariable) {\n console.log(`Outer Variable: ${outerVariable}`);\n console.log(`Inner Variable: $ \n {innerVariable}`); \n }; \n } \n \n const closureFunc = outerFunction("outside"); \n closureFunc("inside");</code></pre>