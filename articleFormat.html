<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=
    , initial-scale=1.0"
    />
    <title>Document</title>
  </head>
  <body>
    I was recently in a situation where I was talking to a senior developer, and he was asking me questions about JavaScript to gauge my knowledge. Before this conversation, I felt confident in my JavaScript knowledge. After that conversation, I felt deflated. I realized I still had a lot of work to do. My goal is to become comfortable with the aspects of JavaScript where I fell short during that conversation. To that end, I want to bring clarity to the JavaScript concept of closures. <br><br><h2>Understanding Closures </h2>Closures can seem tricky at first, but they become easier to understand when broken down. A closure happens when a function can 'remember' and access variables from its outer scope, even after that outer scope has finished executing. This unique behavior allows inner functions to retain access to variables defined in an enclosing function.<br><br><strong>Key takeaway:</strong> Closures enable functions to remember and access variables from their surrounding context, even after that context has finished executing. <br><br><br><h2>Example of a Closure</h2>Here’s a simple example to illustrate how closures work:<br><iframe src='https://www.thiscodeworks.com/embed/677d568d74e4d900142b75ab' style='width: 100%; height: 229px;' frameborder='0'></iframe><br><strong>Explanation:</strong><br><ul><li><code>outerFunction</code> takes a parameter <code>outerVariable</code> and logs it.</li><li>It returns <code>innerFunction</code>, which itself takes a parameter <code>innerVariable</code>.</li><li> <code> innerFunction</code> logs both <code>outerVariable</code> and <code>innerVariable.</code></li><li>Even after <code>outerFunction</code> has finished executing, <code>innerFunction</code> retains access to outerVariable due to the closure.</li></ul>
    
    <h2>Breaking Down the Code</h2><h4>Step 1: Defining the Outer Function</h4><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>function outerFunction(outerVariable) </code></span> <br><code>outerFunction</code> is defined with one parameter, <code>outerVariable.</code><h4>Step 2: Returning the Inner Function</h4><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>return function innerFunction(innerVariable)  </code></span><br>Instead of executing <code>innerFunction</code>, <code>outerFunction</code> returns it.The returned <code>innerFunction</code> retains access to <code>outerVariable</code>.<h4>Step 3: Parameters in Scope</h4><code>outerVariable</code> belongs to <code>outerFunction</code>.<h4>Step 4: Logging Inside the Inner Function</h4><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>console.log(`Outer Variable: ${outerVariable}`);</code></span><br><br><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>console.log(`Inner Variable: ${innerVariable}`);</code></span><br><code>innerFunction</code> logs both <code>outerVariable</code> and <code>innerVariable</code>, demonstrating how closures work.

    <h2>How the Function Calls Work</h2><h4>1. Calling outerFunction</h4><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>const closureFunc = outerFunction("outside");</code></span><br><strong>What happens:</strong><br><ul style='padding-left: 20px;'><li><code>outerFunction</code> is called with the argument "outside".</li><li>It logs "outside".</li><li>It returns <code>innerFunction</code>, which gets stored in <code>closureFunc</code>.</li></ul><h4>2. Calling innerFunction via closureFunc</h4><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>closureFunc("inside");</code></span><br><strong>What happens:</strong><ul style='padding-left: 20px;'><li><code>closureFunc</code> is invoked with the argument "inside".</li><li>innerFunction logs:<br><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>Outer Variable: outside</code></span><br><span style="background-color: rgb(209, 209, 209); padding: 10px;"><code>Inner VAriable: inside</code></span></li><li>Even though <code>outerFunction</code> has completed, <code>innerFunction</code> still has access to <code>outerVariable</code> because of the closure.</li></ul>

    <h2>closureFunc is the returned innerFunction(), which remembers the outerFunction argument (in this case the string 'outside') and takes a new argument for itself.. in this case ('inside')</h2><ol><li>closureFunc is the returned innerFunction.</li><li>It "remembers" the outerFunction argument (via the closure).</li><li>It also accepts a new argument specifically for innerFunction.</li></ol>
            
<a href="https://www.w3schools.com/js/js_function_parameters.asp">parameter</a>


<h2>Common Misunderstandings</h2>Why doesn’t closureFunc("inside") invoke outerFunction?<br>It might seem like calling closureFunc should somehow trigger outerFunction, but here’s the key point:<ul style='padding-left: 40px;'><li>closureFunc is just a reference to innerFunction.</li><li>outerFunction is no longer involved after returning innerFunction.</li></ul>Even though outerFunction has finished executing, its variables remain accessible to innerFunction because of the closure.<h2>Why Closures Matter</h2>Closures are powerful because they allow:<br><ul style='padding-left: 40px;'><li>Data encapsulation: Variables can be kept private within a function.</li><li>Function factories: You can create functions with preset configurations.</li><li>Maintaining state: Closures help manage state in asynchronous operations.</li></ul><br><br>

<h2>Final Thoughts</h2>Closures are a fundamental concept in JavaScript. While they may seem confusing initially, understanding how they work will deepen your knowledge of JavaScript functions and scope. Closures are widely used in callbacks, function factories, and state management in asynchronous code.<br><br>With practice, closures will become a natural and powerful tool in your JavaScript toolkit.

<a href="https://developer.mozilla.org/en-US/docs/Glossary/Scope">scope</a>
</html>


<pre class='language-js'><code class='language-js'>function outerFunction(outerVariable) {\n return function innerFunction(innerVariable) {\n console.log(`Outer Variable: ${outerVariable}`);\n console.log(`Inner Variable: $ \n {innerVariable}`); \n }; \n } \n \n const closureFunc = outerFunction("outside"); \n closureFunc("inside");</code></pre>


I was working on a project that required me to cycle through an array of words and display them one at at time. Sounds simple.</br></br>The goal was clear, show one word, wait a few seconds, show the next, and loop it <a href=’https://www.youtube.com/watch?v=EsMdABK3SKU#t=1m43s’ target=’_blank’> forever</a></br></br>My instinct… A LOOP! That has always been my go-to when iterating over an array.</br></br>But this time, something wasn’t clicking. I’ve never been super confident with JavaScript’s timing functions like setTimeout or setInterval, but I knew this is where I need to be for this timing function to work. </br></br>As I dug deeper, I realized the tools I thought I needed weren’t the ones I actually needed, Enter: the <a href='https://www.w3schools.com/js/js_callback.asp' target=’_blank’>callback function</a>, the <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder' target=’_blank’> modulo operator</a>, and the time-sensitive, often misunderstood <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Remainder' target=’_blank’> setInterval</a>.</br></br>Together, they not only solved my problem, they reshaped the way I think about timed logic in React.</br></br><h2>My First Attempt: forEach + setTimeout</h2></br></br>My first instinct was to use a forEach loop. I thought, 'I'll just loop through the words and use setTimeout to delay each one.'<br></br><h3>WRONG:</h3>

<a href=’https://www.youtube.com/watch?v=EsMdABK3SKU#t=1m43s’ target=’_blank’>FOREVER</a>

<a href='https://www.youtube.com/watch?v=EsMdABK3SKU#t=1m43s' target=’_blank’>FOREVER</a>

In theory, I thought this should have worked:<br/><pre class='language-js'><code class='language-js'>const words = ["Innovate", "Elevate", "Create"]; {\n return function innerFunction(innerVariable) {\n console.log(`Outer Variable: ${outerVariable}`);\n console.log(`Inner Variable: $ \n {innerVariable}`); \n }; \n } \n \n const closureFunc = outerFunction("outside"); \n closureFunc("inside");</code></pre>
<ul><li>Innovate after 0 seconds</li><li></li><li></li></ul>

The problems with this is it runs once on page load, no cycle, no repetition. It doesn’t update React state, so there’s no re-render.	Once the timeouts finish, it’s done, you’d have to manually restart the whole process. What I really wanted was a loop that never ends, a word that updates in state so React re-renders the DOM, and a solution that wouldn’t create dozens of rogue setTimeouts stacking up. It gets messy... That’s when I realized,  React needs a more reactive approach. You see what I did there?</br></br>
<h3>setInterval: What I Actually Needed</h3></br></br>After realizing that forEach and setTimeout weren’t going to cut it, I turned to setInterval. I knew it ran a block of code every X milliseconds, but I had never really used it confidently — especially inside a React component.</br></br>Here’s what a basic version looks like:</br><pre class='language-js'><code class='language-js'>setInterval(() => { \n console.log("This runs every 2 seconds");\n}, 2000);</code></pre>


const [index, setIndex] = useState(0);


  
    
 

  

<pre class='language-js'><code class='language-js'>const [index, setIndex] = useState(0); \n useEffect(() => { \n const interval = setInterval(() => { \n setIndex((prevIndex) => prevIndex + 1); \n  }, 2000); \n return () => clearInterval(interval); // cleanup \n }, []);</code></pre>

<h2></h2>But there was still a problem, what happens when the index reaches the end of the array? That’s where the modulo operator walked in and stated, 'I'll take it from here, you yellow belly...'

This line does two things at once. Increments the index by 1 and Resets it to 0 if it reaches the end of the array. It’s a simple piece of math, but it keeps the app from crashing and creates a perfect loop.


<h2>The Final Working Solution</h2></br>Here’s the final version of the component that cycles through words cleanly, using setInterval, a state callback, and the % operator:







  
  

  
    
      
    

    
  

  return (
    <div>
      <p>{words[index]}</p>
    </div>
  );
}



<pre class='language-js'><code class='language-js'>import { useState, useEffect } from 'react'; \n export default function WordCycle() { \n const words = ['Innovate', 'Elevate', 'Create', 'Accelerate']; \n const [index, setIndex] = useState(0); \n useEffect(() => { \n const interval = setInterval(() => { \n setIndex((prevIndex) => (prevIndex + 1) % words.length); \n }, 2000); \n return () => clearInterval(interval); // Cleanup on unmount \n }, []);</code></pre>

<h2>Final Thoughts</h2> </br> This was one of those moments where I felt like I had to unlearn what I thought I knew. I wanted to reach for my trusty loop, because I always think of loops when working with arrays. But in React, loops aren’t always the answer, especially when you’re dealing with time. The real solution came from combining a callback function that safely updates state, the modulo operator to create a loop, and a setInterval to drive the timing. So the moral of the story is if an array walks into a bar, don't automatically pull a loop on em. 

But there was still a problem… What happens when the index reaches the end of the array?</br>That’s when the modulo operator strolled in, tipped its hat, and said:'I’ll take it from here, you yellow-belly…'


'Twenty-eight days, six hours, forty-two minutes, twelve seconds.'</br></br>That’s how long it felt like I spent trying to measure the height of a div manually before realizing Framer Motion just... handles it. </br></br>And by 'handle it,' I mean: it gave me an animation that worked the first time. No `useRef`, no `scrollHeight`, no `setTimeout` no confusion at all, unlike that time I woke up on a putting green with no idea how I got there. Just smooth, expanding UI bliss with `height: "auto"`. </br></br> Wait... Who woke up on a putting green?

<h1>I Was Just Trying to Unfurl Some Divs</h1>I love the look of a section that expands smoothly, like when you click a category and the content unfurls beneath it. (Is that the right word? Maybe not. But it fits my vibe.)

In my case, I was mapping out categories, each opening up a group of feature rows. Each row had content that could grow, including a video player that revealed itself with a button click. So I used `useRef` to measure the height on open. It mostly worked... until it didn't. Nested videos broke everything. The `ref` wouldn't pick up the change fast enough. `scrollHeight` came back stale. I threw in `setTimeout`. I was trying to force the DOM to bend to my will.</br></br>And that’s when Donnie's voice popped into my head:</br></br>'There are other things that need to be taken into account here, like the whole spectrum of framer motion.</br></br>Wait... Framer Motion?

<h2>The ScrollHeight Spiral</h2></br></br>So the idea is: when new content renders, use the ref to measure `scrollHeight`, then animate your container to that height. It works in many cases.</br></br>It works… until it doesn’t. And that’s when the doubt sets in. And suddenly you’re staring at your console like Grandma Death at her mailbox, waiting for a message that means something this time.  Not just in your code, but in your commitment to layout animation as a concept. </br></br> I was questioning my commitment to Framer Motion. </br></br> <></ <strong>**Dev tip:**</strong> If you ever want to see what else you can play with in a ref, run `console.log(ref.current)` — it opens up a whole world of DOM properties you can poke at. Height, width, offset, class list, children, you name it. Great for tinkering.em>

<h2>The Sparkle Motion Moment</h2></br>There’s a scene in Donnie Darko where Kitty Farmer shouts:</br><strong>Sometimes I doubt your commitment to Sparkle Motion!”</strong></br></br>That line echoed in my head as I was struggling with this issue... and then, like through a wormhole, it was presented to me: `height: "auto"`. Surely that can’t work. Browsers don’t animate to `auto`, right? But I tried it anyway. </br></br>



<pre class='language-js'><code class='language-js'>  initial={{ height: 0, opacity: 0 }} \n animate={{ height: "auto", opacity: 1 }} \n exit={{ height: 0, opacity: 0 }} \n transition={{ duration: 0.3 }} \n transition={{ duration: 0.3 }}</code></pre>



  <pre class='language-js'><code class='language-js'>import { useState, useEffect } from 'react'; \n export default function WordCycle() { \n const words = ['Innovate', 'Elevate', 'Create', 'Accelerate']; \n const [index, setIndex] = useState(0); \n useEffect(() => { \n const interval = setInterval(() => { \n setIndex((prevIndex) => (prevIndex + 1) % words.length); \n }, 2000); \n return () => clearInterval(interval); // Cleanup on unmount \n }, []);</code></pre>

  <pre class='language-js'><br class='language-js'>  initial={{ height: 0, opacity: 0 }} \n animate={{ height: 'auto', opacity: 1 }} \n exit={{ height: 0, opacity: 0 }} \n transition={{ duration: 0.3 }} \n transition={{ duration: 0.3 }}</code></pre>

  <h2>What’s Actually Happening</h2>


  <pre class='language-js'><code class='language-js'> \n initial={{ height: 0, opacity: 0 }} \n animate={{ height: 'auto', opacity: 1 }} \n exit={{ height: 0, opacity: 0 }} \n transition={{ duration: 0.3 }} \n transition={{ duration: 0.3 }}</code></pre>

  <h2>What’s Actually Happening</h2></br>Framer Motion uses a layout measurement system internally — so when you use `height: "auto"` in a `motion.div`, it temporarily measures the height before and after render, and animates the change .It’s like `scrollHeight`, but with none of the stress. It also plays beautifully with `AnimatePresence`, so your exits are as clean as your entrances.† </br></br>† *This excludes Frank’s.*

<h2>So Should You Ditch `useRef` Forever?</h2></br> Definitely not. I still find `useRef` incredibly useful — especially when working with video elements. I’ve used it to access the duration of a video. It’s great for tapping into properties you can't reach through state or props alone.But when it comes to animating height based on content — especially when that content changes dynamically — I’ve stopped reaching for `ref`. If `height: "auto"` gets me there without the hassle? I’m in.</br></br> Sometimes, you just gotta trust the Motion. </br></br> After all, it's not the size of the `ref` — it's the Framer of the Motion... or something like that.

<h2>Final Thoughts</h2></br>They say fear and love are the deepest of human emotions. But did that person ever get caught up in a front-end development bug? Because that got me in some **deep** emotions. 'What if you could go back in time, and take all those hours of pain and darkness and replace them with something better?' Gretchen said in the movie. </br></br>Yes I do, Gretchen. Yes I do... But maybe those rough learning patches, the ones where you wake up confused on a metaphorical putting green, unsure how you even got there, are what shape us the most. Not just as developers, but as thinkers, builders, and people willing to wrestle with complexity until something clicks.</br></br> And I no longer doubt my commitment to Framer Motion.

<a href="https://latestartbucket.s3.us-east-2.amazonaws.com/video/Darko-intro.mp4"></a>



